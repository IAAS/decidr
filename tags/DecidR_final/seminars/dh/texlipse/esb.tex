% %%%%%%%%%%%%%%%%%%%% esb.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  The main
% chapters.  %%%%%%%%%%%%%%%%%%% Springer-Verlag template %%%%%%%%%%%%%%%%%
\begin{abstract}
In most organizations, technological heterogenity is more the rule than the
exception. While new software applications are often built with integration in
mind and using promising approaches such as service-oriented architecture (SOA), valuable
business data remains locked up within existing applications. The Enterprise
Service Bus (ESB) is an integration middleware that enables an SOA by
coordinating the communication between (web) services and those existing
applications. In this paper we'll take a look at how the DecidR application can
benefit from the Apache Synapse ESB despite being developed in a
homogenous SOA environment. In addition we'll look into the value that Web
Services Securtiy (WSS) can add to the project.
\end{abstract}

\section{Enterprise Service Bus}
\label{chap:enterprise-service-bus}
As an organization or business grows, so does the number of software applications
that need to communicate with each other in order to exchange business data.
Unless integration is considered an important matter early, it is very likely
that an ``accidental architecture'' will emerge:

\img{figures/network-point-to-point.pdf}{The problem: point to point connectivity
between applications requires definition, implementation and maintenance of
$\mathcal{O}(n^2)$ interfaces.}{fig:network-point-to-point}

Enterprise Application Integration (EAI) is an attempt to reduce integration
complexity and costs by introducing a mediator. Applications connect to a central
integration broker via an adapter, which significantly reduces the
number of interfaces that need to be developed and maintained.

\img{figures/network-hub-and-spoke.pdf}{The hub-and-spoke integration network
reduces complexity to $\Theta(n)$ interfaces.}{fig:network-hub-and-spoke}

A major disadvantage of previous EAI implementations is that most rely on
proprietary, competing standards, making business-to-business communication
difficult. Also, all information must traverse the central hub, which prohibits
a highly distributed infrastructure on the side of the integration broker.
In contrast, a distinguishing key feature of an ESB is its
distributable infrastructure:

\newpage
\img{figures/network-bus.pdf}{The bus topology allows for
highly distributed deployment.}{fig:network-bus}
Unfortunately, there is no standardized definition of what comprises an ESB and
what doesn't. Some comfort can be taken from the description of a
set of capabilities that make the basis of an ESB, given by David Chappell, a
major contributor to the emergence of the term: 

\begin{mycite}{chappell}
An ESB is a standards-based integration platform that
combines messaging, web services, data transformation and intelligent routing to
reliably connect and coordinate the interaction of significant numbers of
diverse applications \ldots with transactional integrity.
\end{mycite}

\subsection{XML}
\label{sec:xml}

Connecting diverse applications requires a loosely coupled, flexible and
extensible data model such as the one provided by XML / XML Schema. It is widely
used in available ESB implementations\supercite{chappell}. With the Extensible Stylesheet
Language Transformations (XSLT) an xml-to-any data transformation language is also
available. (see section \ref{subsec:data-transformation})

\subsection{Endpoints}
\label{sec:endpoints}

From a conceptual view, the ESB functionality is hidden behind
abstract endpoints. Endpoints are just logical abstractions of services that are
connected into the ESB. Endpoints also abstract from the underlying protocol or
message queueing implementation. An endpoint may represent many things, such as a
single operation of an exam registration service. The actual implementation of
the endpoint may use an application that is deployed on a local server, or may
redirect to an external web service. An endpoint may just as well represent a
legacy application that handles matriculation management, an Enterprise Resource
Management (ERP) system or even an entire department of a University, such as the
IAAS. Each endpoint is an equal SOA participant regardless of what it
represents.

It is the task of an integration architect to connect these endpoints by
defining routing rules, data transformations and business process logic. (Service
orchestration)

\img{figures/esb-endpoints.pdf}{Everything that is connected into the bus is
viewed as an abstract endpoint. Drawn using Sonic Software
ESB Visio Stencils \supercite{sonic-icons}}{fig:esb-endpoints}

\newpage
\subsection{ESB Tasks}
\label{sec:esb-tasks}

\subsubsection{Messaging}
\label{subsec:messaging}
Message-oriented Middleware (MOM) is a key part of the ESB. All
communication operations are performed on self-contained units of information
called messages. This allows each communication operation to be a
self-contained, standalone unit of work.\supercite{chappell} At the core of the
ESB sits a powerful messaging system such as the Java Messaging Service (JMS)
that provides asynchrous and event-driven messaging capabilities.

\subsubsection{Mediation and Invocation}
\label{subsec:mediation-and-invocation}

The ESB must support many transport protocols and be able to convert between them
in order to enable communication between many different applications. The ESB
should support synchrous as well as asynchrous transports, and event-driven
messaging via publish / subscribe. For legacy applications the ESB must support
the creation of adapters that build a service frame around the application.

\subsubsection{Content-based Routing}
\label{subsec:content-based-routing}

A content-based routing (CBR) service decides which endpoint(s) receive messages
that pass through the ESB. The routing decisions are based on a set of rules
that may be defined by configuration files, scripts or programs. The routing
rules may be based on the content of each message such as specific XML
elements / attributes or message metadata.

\subsubsection{Data transformation}
\label{subsec:data-transformation}

is a capability that applies mostly to XML documents. The
ESB can use transformation rules such as XSLT documents to covert between XML
dialects or enrich messages with additional information.

\img{figures/data-transformation.pdf}{In this example data transformation is
used to provice compatibility of a legacy application without having to modify
its code.}{fig:data-transformation}

\subsubsection{Quality of Service}
\label{subsec:quality-of-service}

The loose coupling that can be achieved in an SOA gives the ESB an opportunity
for optimization. Since services may be deployed accross several physical nodes,
the ESB can include server load in its routing decisions and provide a failover
option.

Furthermore, a good ESB provides reliable communication channels using standards
such as WS-ReliableMessaging and WS-Reliability. It also supports encryption and
signatures, which provides end-to-end security that doesn't depend on the
underlying protocol for its services.

\subsubsection{Management}
\label{subsec:management}

Since the entire data flow in an SOA passes through the ESB, it is
fit for monitoring, logging or audits.

%\subsubsection{Vetro integration pattern?}
%\newpage
\subsection{ESB Usage in DecidR}
\label{subsec:esb-usage-in-decidr}

From what we can tell at this point, the DecidR application is being developed
in a pure SOA environment with no requirements pointing to integration with
existing applications. However, we also can't declare impossible that such a
requirement arises at a later project phase. Therefore it is reassuring
to have an integration platform ready in such a case.
The DecidR system components are implemented using web service technology,
which is natively supported by the ESB; the effort for ``getting on the
bus'' is minimal, but comes with certain benefits:

\subsubsection{Service Discovery / Invocation}
\label{subsec:service-discovery-incovation}

The service bus adds a layer of indirection that allows service instances to be
moved to other physical locations without having to modify the adressing
configuration of the clients.

\img{figures/decidr-virtualization.pdf}{DecidR subsystems
invoke web services through the ESB,
never knowing where the actual service instance is
located.}{fig:service-virtualization}

\newpage
\subsubsection{Load Balancing and Service Availability}
\label{subsec:load-balancing-and-service-availability}
%%
If necessary due to high server load, multiple instances of a service can be
run on different physical nodes. The ESB will then take care of
automatically balancing the load across multiple service instances.

The same mechanism can be used to provide high availability by temporarily
disabling a defunct service endpoint and switching automatically to another
service endpoint that provides the same functionality. See chapter
\ref{chap:synapse-sample-configurations} for samples.

\subsubsection{Logging}
\label{subsec:logging}
The logging capabilities of the ESB can be used for debugging and
administration of the DecidR application. Intense logging during the
development phase is highly recommended by the client.

%\newpage
\subsection{Apache Synapse}
\label{sec:apache-synapse}

Due to the limited experience of the project team with SOA, web services, etc.
a service bus that doesn't unnecessarily complicate things is desirable. In
the following section we're going to take a look at Apache Synapse, which
claims to be a ``lightweight'' ESB and is built upon the Axis2 web services
engine. Its main features as advertised by the project website are:

\begin{mycite}{synapse}
Apache Synapse is an ESB that has been designed to be simple to configure, very
fast, and effective at solving many integration and gatewaying problems. Synapse
has support for HTTP, SOAP, SMTP, JMS, FTP and file system transports, Financial
Information eXchange (FIX) and Hessian protocols for message exchange as well as
first class support for standards such as WS-Addressing, Web Services Security
(WSS), Web Services Reliable Messaging (WSRM), efficient binary attachments
(MTOM/XOP). Synapse can transform messages using key standards such as XSLT,
XPath and XQuery, or simply using Java. Synapse supports a number of useful
functions out-of-the-box without programming, but it also can be extended using
popular programming languages such as Java, JavaScript, Ruby, Groovy, etc\ldots
\end{mycite}

Synapse is configured using an XML file that contains the mediation rules for
routing incoming and outgoing messages, data transformations, etc. For a
complete description of the XML configuration language please refer to 
\supercite{syncf}. The second
releavant configuration file is axis2.xml, where the underlying Axis2 engine
that provides the transport protocols is configured.

\imgstatic{9cm}{figures/synapse-service-mediation.pdf}{Synapse service
mediation, based on \supercite{syncf}}{fig:synapse-service-mediation}

Synapse supports two modes of operation: in \emph{message mediation} mode
the clients must be configured to use the Synapse node as a HTTP proxy.
In \emph{service mediation} mode, Synapse explicitly exposes existing services
or applications as services using the underlying Axis2 engine. Client
applications communicate directly with the bus.

\subsubsection{Deployment}
\label{subsec:deployment}

To install Synapse, simply unpack the standard binary distribution from
\url{http://synapse.apache.org/download/1.2/download.cgi} to a directory of
your choice. Before running Synapse, you musti nstall the latest 32 bits JDK on
your system.

Alternatively you may use the package that is bundeled with this document. It
contains the samples that are covered in the next chapter.

%\newpage
\section{Synapse sample configurations}
\label{chap:synapse-sample-configurations}
\lstset{frame=single,
	    basicstyle=\tiny,
	    numbers=left,                   
		numberstyle=\tiny, 
	    commentstyle=\textit,
	    breaklines=true}

The standard distribution of Synapse v1.2 comes with 56 sample configuations that
are very helpful for understanding its functionality. In this section, we will
explore some sample configurations that are loosely based on the standard
samples. Of course, the following samples only show the tip of the iceberg, many
features remain unmentioned. However, the topics that are actually relevant to
the DecidR application (load balancing, logging\ldots) are addressed.

\subsection{Sample 1: Open Proxy}
\label{sec:sample-1}
We start with a very simple configuration that basically does nothing except
logging any incoming messages, then sends the messages to their implicit
destination. Implicit means that Synapse must be able to automatically
determine the final destination of the message based on the message contents,
URL, SOAP header properties, or some other bits of information that are attached to
the message.
\begin{itemize}
  \item Start Axis2: \texttt{synapse-1.2/samples/axis2Server/axis2server -http
  9000 -https 9002}
  \item Run Synapse: \texttt{synapse-1.2/bin/synapse -sample 1}
\end{itemize}

\lstset{caption=, label=sample-1-xml}
\lstinputlisting{listings/synapse_sample_1.xml}

To test this configuration, start up SoapUI and create a new project. Enter a
project name and use \url{http://localhost:9000/soap/TimeService?wsdl} as the
initial WSDL. Create a test suite for the imported WSDL. Now go to the
preferences and make SoapUI connect through the Synapse proxy at localhost:8280.

\begin{center}
\includegraphics[width=8cm]{figures/soapui-proxy.pdf}
\end{center}

If the test suite is run, the SOAP response should look similar to this: 

\lstset{caption=, label=sample-1-result-xml}
\begin{lstlisting}
<soapenv:Envelope xmlns:soapenv="http://www.w3.org/2003/05/soap-envelope">
   <soapenv:Body>
      <ns:getTimeResponse xmlns:ns="http://esb.seminar.decidr.de">
         <ns:return>2009-01-05T06:42:24.832Z</ns:return>
      </ns:getTimeResponse>
   </soapenv:Body>
</soapenv:Envelope>
\end{lstlisting}

\newpage
\subsection{Sample 2: Simple Service Gateway}
\label{sec:sample-2}

In this sample we turn Synapse into a gateway for an existing web service.

\begin{itemize}
  \item Start Axis2: \texttt{synapse-1.2/samples/axis2Server/axis2server -http
  9000 -https 9002}
  \item Run Synapse: \texttt{synapse-1.2/bin/synapse -sample 1}
\end{itemize}

\lstset{caption=, label=sample-2-xml}
\lstinputlisting{listings/synapse_sample_2.xml}

Navigating to \url{http://localhost:8280/soap} with any web browser reveals the
underlying Axis2 server. The web service it hosts simply forwards all messages
 to \url{http://localhost:9000/soap/TimeService}.

\begin{center}
\includegraphics[width=4cm]{figures/timeproxy-success.pdf}
\end{center}

\newpage
\subsection{Sample 3: Service Gateway with Load Balancing}
\label{sec:sample-3}

Now that we know how to set up a service proxy, we can add load balancing to
its endpoint. Currently Synapse supports spreading all incoming requests over a
set of endpoints in a round-robin fashion.

\begin{itemize}
  \item Start 3 Axis2 servers:
  \begin{itemize}
    \item \texttt{synapse-1.2/samples/axis2Server/axis2server -http 9000 -https 9002}
    \item \texttt{synapse-1.2/samples/axis2Server/axis2server -http 8000 -https
    8002}
    \item \texttt{synapse-1.2/samples/axis2Server/axis2server -http 7000 -https
    7002}
  \end{itemize}
  \item Run Synapse: \texttt{synapse-1.2/bin/synapse -sample 3}
\end{itemize}

\lstset{caption=, label=sample-3-xml}
\lstinputlisting{listings/synapse_sample_3.xml}

This configuration exposes a single web service to the client, but actually
forwards incoming messages to one of three service endpoints:

\imgstatic{10cm}{figures/decidr-loadbalancing-1.pdf}{Using a
virtual endpoint to implement load balancing.}{fig:decidr-loadbalancing-1}

\newpage

\subsection{Sample 4: Retrieval of an External Configuration via the Registry}
\label{sec:sample-4}

Multiple instances of Synapse can share the same configuration by using
the registry to retrieve the mediation definitions from a remote source.

\begin{itemize}
  \item Start Axis2: \texttt{synapse-1.2/samples/axis2Server/axis2server -http
  9000 -https 9002}
  \item Run Synapse: \texttt{synapse-1.2/bin/synapse -sample 4}
\end{itemize}

\lstset{caption=, label=sample-4-xml}
\lstinputlisting{listings/synapse_sample_4.xml}

The resulting configuration is the same as in example \#3.

\newpage
\section{Web Services Security}
\label{chap:web-services-security}

In a nutshell, the goal of WS-Security is to enable applications to conduct
secure SOAP message exchanges\supercite{ws-sec} independently from the underlying transport
protocol. WS-Security itself does not guarantee a secure architecture, it only
provides the means to encrypt or sign the headers and contents of SOAP
messages. The standard was initially developed by IBM, Microsoft, VerySign and
Sun. The 1.0 version was released by the Organization for the Advancement
of Structured Information Standards (OASIS) in 2004. The current version 1.1
was released in 2006.

%\newpage
\subsection{Comparison to Transport Layer Security}
\label{sec:comparison-to-transport-layer-securtiy}

With WS-Security we have end-to-end security, which means that sensitive data
stays encrypted \emph{all the way} to its final destination. Transport layer
security such as HTTPS cannot guarantee end-to-end security due to
the fact that a message may travel through more than one logical network node.
Not only would every network node between initial sender and ultimate reveiver
know the secret conents of that message, but there is also no guarantee that the 
underlying transport protocol doesn't change in between.

\img{figures/tls-vs-e2e.pdf}{In an SOA transport layer security
is not sufficient because the underlying transport protocol may
change between sender and receiver of a message.}{fig:tls-vs-e2e}

%\newpage
\subsection{WS-Security in DecidR}
\label{subsec:ws-security-in-decidr}

Security is an important requirement for DecidR, especially concerning privacy
protection obligations and resilience to attacks on
sensitive data \supercite{decidr-spec}. Therefore all communication between
client applications, DecidR web services and \emph{external} web services should
be encrypted. WS-Security supports X.509 certificate based authentication as 
described by \supercite{x509}, which provides the DecidR project team with a 
professional approach for secure message exchanges between the system
components:

\img{figures/decidr-security-1.pdf}{The Synapse ESB can
act as a trusted service mediator with enabled security
features.}{fig:decidr-security-1}

%\newpage
\subsection{Using WS-Security with Synapse}
\label{subsec:using-ws-security-with Synapse}

Adding WS-Security support in Synapse is done simply by
adding the \texttt{<enableSec>} element to a \texttt{<proxy>} or
\texttt{<address>} definition, along with a \texttt{<policy>} element that
specifies the attached security policy.

As a result, it's quite easy to create a service proxy that comes with
WS-Security features, even though the actual service endpoint does not support
WS-Security. The following listing shows a sample Synpase configuration file
that achieves this. Note that this approach only makes sense if there's a need
to provide faked security to a client, since the communication between Synapse
and the actual service endpoint remains possibly unencrypted.

\newpage
\lstset{caption=, label=sample-security-xml}
\lstinputlisting{listings/synapse_sample_security.xml}

\img{figures/decidr-security-2.pdf}{The resulting
configuration provides secure communication between the client and Synapse,
although this might give the client a false impression
of the overall security of the message exchange.}{fig:decidr-security-1}