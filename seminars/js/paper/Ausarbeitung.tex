\documentclass{llncs}
\usepackage[ngerman]{babel} 
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{listings}



\begin{document}
\lstset{basicstyle=\ttfamily, numberbychapter=false, xleftmargin=0.5cm}

\title{JavaScript, Ajax \& JavaScript-Frameworks}
\toctitle{Inhaltsverzeichnis}
\author{Jonas Schlaak}
\institute{Institut für Architektur von Anwendungssystemen}
\maketitle

\section{Einleitung}

\subsection{JavaScript}
JavaScript ist eine Skriptspache, die für den Einsatz in Webbrowsern verwendet wird. Sie wurde 1995 unter dem Namen LiveScript von der Firma Netscape Communications entwickelt. Die Syntax von JavaScript ist an die der C-Programmiersprache angelehnt und folgt objektorientierten Programmierparadigmen. Mittlerweile ist JavaScript durch die Ecma International standardisiert (ECMA 262)\cite{ecma}.

\subsection{Ajax}\label{ajax}
Der Beriff "`Ajax"' stammt von Jesse Garrett, der ihn erstmals in einem Artikel von 2005\cite{ajax} verwendete. Unter "`Ajax"' oder "`AJAX"' verstand er ursprünglich eine Abkürzung  für "`\textbf{A}synchronous \textbf{J}avaScript \textbf{a}nd \textbf{X}ML"'. Seitdem wird Ajax als Begriff für eine Sammlung von Technologien oder als ein Konzept verwendet, die bei der Entwicklung von dynamischen, an Desktopanwendungen erinnernde, Webseiten zum Einsatz kommen. Anders als die ursprüngliche Bedeutung von Ajax suggeriert, muss dabei keinesfalls XML oder Asynchronität verwendet werden.

\begin{figure}[hb]
\centering
\includegraphics[width=0.8\textwidth]{Bild1.png}
\caption{Das Schema von herkömmlichen Webanwendungen}
\label{alt}
\end{figure}

Mit Ajax wird die Zustandslosigkeit des Http-Protokolls und damit der Webseiten scheinbar umgangen. Traditionell muss der Webclient (Browser) bei jeder Änderung einer Seite oder Aktion durch den Benutzer erneut eine Anfrage an den Server schicken. Die Änderungen oder Aktionen werden vom Server verarbeitet und eine entsprechend veränderte Seite wird an den Client zurückgeschickt (siehe Abbildung \ref{alt}). Gegenüber herkömmlichen Desktopanwendungen hat dies den Nachteil, dass der Aktionsfluss des Benutzers unterbrochen wird oder, abhängig von der Verbindung, Wartezeiten und Unterbrechungen entstehen.

Garrett beschreibt in seinem Artikel\cite{ajax} eine "`Ajax-Engine"', eine clientseitige Komponente, die zwischen dem Server und dem eigentlichen Client, mit dem der Benutzer interagiert, zwischengeschaltet wird (siehe Abbildung \ref{ajaxmodel}). Die Ajax-Engine umgeht die Nachteile traditioneller Webanwendungen, indem die Anfragen des Clients zunächst an die Engine gehen. Die Engine wiederum ist in der Lage, gezielt Anfragen nach Daten, die benötigt werden, an den Server zu stellen. Aktionen des Benutzers, die keine Daten vom Server benötigen, wie beispielsweise die Validierung von Daten, können von der Engine selbstständig verarbeitet werden. Die Daten, die der Server als Antwort auf die Anfragen der Engine liefert, können per JavaScript in die Webseite eingebunden werden. Die Interaktion des Benutzers mit der Webseite wird also nicht von der Kommunikation mit dem Server beeinflusst. Ein Beispiel für diesen Vorgang liefert das folgende Szenario: Ein Benutzer sucht nach Einträgen in einem Telefonbuch. Er grenzt seine Anfrage durch die Eingabe der ersten Buchstaben des Nachnamens und der Postleitzahl ein. Die Ajax-Engine prüft, ob die eingegebene Pstleitzahl nur aus Ziffern besteht. Gleichzeitig sendet sie eine entpsrechende Suchanfrage an den Server. Die Validierung und die Anfrage werden durch die Eingabe des Benutzers ausgelöst, also ohne explizites Wissen des Benutzers. Die gefundenen Einträge des Servers werden durch die Engine verarbeitet und  als Tabelle auf der Webseite angezeigt. Dieser Vorgang widerholt sich bei jeder neuen Eingabe des Benutzers. Die Suchergebnisse werden also dynamisch aktualisiert. Der Benutzer nimmt nicht explizit war, dass mit einem Server kommuniziert wird.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{Bild2.png}
\caption{Das Schema von Ajax-Webanwendungen}
\label{ajaxmodel}
\end{figure}

\section{Das \texttt{XMLHttpRequest}-Objekt}
In Abschnitt \ref{ajax} wurde das Ajax-Interaktionkonzept erläutert, das vorsieht, die Serveranfragen und das Nachladen von Daten ohne Unterbrechung der Benutzeraktionen durchzuführen. Im Folgenden wird auf die technische Verwirklichung eingegangen. Das unterbrechungsfreie Anfragen und Nachladen wird duch das \texttt{XMLHttpRequest}-Objekt ermöglicht. Das \texttt{XMLHttpRequest}-Objekt wurde ursprünglich von Microsoft als Bestandteil von ActiveX mit dem Internet Explorer 5 eingeführt. Mittlerweile ist es bei allen gängigen Browsern ein natives JavaScript-Objekt.

\subsection{Erzeugen und Absenden von Serveranfragen}
Zunächst muss ein neues \texttt{XMLHttpRequest}-Objekt erzeugt werden:
\begin{lstlisting}[caption="", captionpos=b]
var request = new XMLHttpRequest();
\end{lstlisting}
Das Objekt selbst stellt die Methoden \texttt{open()} und \texttt{send()} zur Verfügung, um Anfragen an den Server vorzubereiten und abzusenden.
\begin{lstlisting}[caption="", captionpos=b]
request.open("get", "webpage.html", true);
request.send();
\end{lstlisting}
Im vorhergehenden Beispiel wird mit \texttt{open()} eine GET-Anfrage nach der Web-Ressource \texttt{webpage.html} an den Server vorbereitet und anschließend mit \texttt{send()} verschickt. Das dritte Argument \texttt{true} gibt an, dass der nachfolgende JavaScript-Code ausgeführt wird, ohne auf eine Antwort des Servers zu warten. Durch diese asynchrone Kommunikation kann der Benutzer weiterhin mit der Webanwendung interagieren, ohne dass er durch das Laden der Daten vom Server unterbrochen wird.

\subsection{Das Attribut \texttt{readyState}}\label{beispiel}
Das \texttt{XMLHttpRequest}-Objekt besitzt das Attribut \texttt{readyState}, um den Zustand einer Serveranfrage und den einer eventuellen Antwort abfragen zu können. Das Attribut kann, wie in Tabelle \ref{attwerte} beschrieben, fünf verschiedene Integer-Werte annehmen.
\begin{table}
\centering
\begin{tabular}{|c|l|l|}
\hline
\textsc{Wert} & \textsc{Bezeichnung} & \textsc{Bedeutung} \\
\hline
0 & UNSENT & Standardzustand des \texttt{XMLHttpRequest}-Objekts\\
1 & OPENED & Die \texttt{open()}-Methode wurde aufgerufen\\
2 & HEADERS\_RECEIVED & Die Header der Serverantwort wurden empfangen\\
3 & LOADING & Der Body der Serverantwort wird empfangen\\
4 & DONE & Die Serverantwort wurde vollständig empfangen\\
\hline
\end{tabular}
\caption{Die möglichen Werte des Attributs \texttt{readyState}}
\label{attwerte}
\end{table}
Mit Hilfe des Attributs \texttt{onreadystatechange} ist es möglich, eine Funktion zu definieren, die bei jeder Änderung von \texttt{readyState} aufgerufen wird. Innerhalb der Funktion kann dann durch Fallunterscheidung definiert werden, welche Aktionen für den jeweiligen Zustand ausgeführt werden sollen:
\begin{lstlisting}[caption="", captionpos=b]
request.onreadystatechange = example();

function example() {
  if (request.readyState == 4) {
    /* Die Antwort des Servers ausgeben */
    document.write(request.responseText);
  }
}
\end{lstlisting}

\section{JavaScript Object Notation (JSON)}
JSON ist ein strukturiertes Datenformat für den Datenaustausch. Es wurde mit dem Ziel entwickelt, sowohl menschenlesbar als auch einfach zu parsen sein. JSON ist als Teilmenge von JavaScript Bestandteil der ECMA-262-Spezifikation\cite{ecma}, \cite{json}. In einer Ajax-Webanwendung dient JSON als Alternative zum XML-Format.
\subsection{Objekte und Arrays}
In JSON gibt es zwei wesentliche Elemente: Objekte und Arrays.

Ein Objekt ist eine unsortierte Menge von Schlüssel-Wert-Paaren. Ein Objekt beginnt mit \{ und endet mit \}. Der Schlüssel und der Wert eines Paares wird durch \texttt{:} getrennt. Schlüssel-Wert-Paare eines Objekts werden durch ein Komma getrennt. Ein Beispiel:
\begin{lstlisting}[caption="", captionpos=b]
var json_objekt = {"Schlüssel_1":"Wert_1","Schlüssel_2":"Wert_2"};
\end{lstlisting}
Ein Wert kann ein String, eine Zahl, ein boolscher Wert oder wiederum ein Objekt oder ein Array sein.

Ein Array ist eine sortierte Liste von Werten. Ein Array beginnt mit [ und endet mit ]. Jeder Wert wird durch ein Komma getrennt. Ein Beispiel:
\begin{lstlisting}[caption="", captionpos=b]
var json_array = ["Wert_1", "Wert_2", "Wert_3"];
\end{lstlisting}
\subsection{Die \texttt{eval()}-Funktion}
Der Vorteil von JSON liegt in der einfachen Repräsentation von Objekten und Arrays als Zeichenkette. Die (De-)Serialisierung von Daten ist somit einfach zu bewerkstelligen. Um eine Zeichenkette wieder in ein JavaScript-Objekt oder -Array umzuwandeln, wird die \texttt{eval()}-Funktion benötigt. Mit ihr ist es möglich, eine Zeichenkette als Parameter zu übergeben, die als JavaScript-Code ausgeführt wird. Im folgenden Beispiel wird eine Zeichenkette im JSON-Format vom Server zurückgegeben:
\begin{lstlisting}[caption="", captionpos=b]
{"Name":"Max Mustermann", "Wohnort":"Stuttgart"}
\end{lstlisting}
Sei \texttt{request} das \texttt{XMLHttpRequest}-Objekt (siehe Abschnitt \ref{beispiel}), welches die Anfrage geschickt hat.
\begin{lstlisting}[caption="", captionpos=b]
request.onreadystatechange = example();

function example() {
  if (request.readyState == 4) {
    /* Die Antwort des Servers in ein JSON-Objekt umwandeln */
    var json_objekt = eval("(" + request.responseText + ")");
    document.write(json_objekt.Name + " wohnt in "
        + json_objekt.Wohnort + ". ");
  }
}
\end{lstlisting}
Das obige Code-Beispiel würde zur Ausgabe "`Max Mustermann wohnt in Stuttgart."' führen.

\section{Frameworks}
Um die Erzeugung von und den Umgang mit interaktiven Elementen einer Webseite zu erleichtern, gibt es eine Reihe von JavaScript-Frameworks, die bereits fertige Funktionen für den Webprogrammierer zur Verfügung stellen. Im Folgenden werden ein paar dieser Frameworks behandelt, speziell wird dabei auf den Aspekt eingegangen, ob und wie graphische Objekte handzuhaben und zu manipulieren sind. Dies wird am Beispiel der Erzeugung eines Rechtecks demonstiert, das verschiebbar und in der Größer veränderbar sein soll.

\subsection{jQuery}
jQuery wurde von John Resig entwickelt und im Januar 2006 vorgestellt\cite{jquery}. Es ist wahlweise unter der MIT- oder GNU-Lizenz erhältlich.

\subsubsection{Einbindung}\label{import} Das komplette jQuery-Framework wird als einzelne JavaScript-Datei \texttt{jquery.js} ausgeliefert. Um das Framework zu laden, muss folgende Zeile in einem HTML-Dokument vorhanden sein:
\begin{lstlisting}[caption="", captionpos=b]
<script type="text/javascript" src="jquery.js"></script>
\end{lstlisting}

\subsubsection{Benutzung}
Ein Beispiel für den Aufbau eines HTML-Dokuments bei der Benutzung von jQuery:
\begin{lstlisting}[caption="", captionpos=b]
<html>
<head>
  <script type="text/javascript" src="jquery.js"></script>
  <script>
  $(document).ready(function(){
    $("a").click(function(){
      alert("Hallo Welt!");
    });
  });
  </script>
</head>
<body>
  <a href="">Link</a>
</body>
</html>
\end{lstlisting}
Das \$-Zeichen ist ein Alias für die jQuery-Klasse. Damit ist \texttt{\$()} ein Konstruktor. Übergibt man diesem Konstruktor ein Objekt als Parameter, wird das Objekt als ein jQuery-Objekt behandelt. In der \texttt{ready}-Methode wird der Code angegeben, der ausgeführt werden soll, wenn die Webseite fertig geladen worden und bereit für Interaktion mit dem Benutzer ist. In diesem Beispiel werden alle \texttt{a}-Objekte (HTML-Anker-Objekte) ausgewählt. Mit der \texttt{click}-Methode wird ein Mausklick-Event mit allen Ankerobjekten verknüpft. Die nachfolgende Funktion spezifiziert, was bei einem Mausklick passieren soll. In diesem Fall wird "`Hallo Welt!"' in einem Popup-Fenster ausgegeben.

\subsubsection{Grafik und Interaktion}
jQuery bietet von sich aus keine Möglichkeiten, eigene graphische Objekte zu erzeugen. Vielmehr können vorhandene graphische Objekte (z.B. eine farbige \texttt{div}-Fläche) bestimmte Interkationsmöglichkeiten zugeschrieben werden. Diese Anzahl der Möglichkeiten ist beschränkt, es gibt momentan zwei wesentliche Eigenschaften:
\begin{itemize}
\item "`draggable"', sorgt dafür, dass ein Objekt verschoben werden kann
\item "`resizable"', sorgt dafür, dass ein Objekt in seiner Größe verändert werden kann
\end{itemize}
Ein Beispiel für die Erzeugung eines verschiebbaren Rechtecks:
\begin{lstlisting}[caption="", captionpos=b]
<html>
<head>
  <script src="http://code.jquery.com/jquery-latest.js"
  </script>
  <script src="http://ui.jquery.com/latest/ui/ui.core.js">
  </script>
  <script src="http://ui.jquery.com/latest/ui/ui.draggable.js">
  </script>

  <script>
  $(document).ready(function(){
    $(".block").draggable();
  });
  </script>
  <style>
  .block { 
    border: 1px solid #000000;
    background-color: #0000FF;
    width: 160px; 
    height: 80px;
    margin: 10px; 
  }
  </style>
</head>
<body>
  <div class="block"></div>
</body>
</html>
\end{lstlisting}
Das obige Beiscpiel beschreibt die Erzeugung eines \texttt{<div>}-Elements, dessen Aussehen über den \texttt{<style>}-Block definiert wird. Im jQuery-Block wird dieses Element selektiert und mit der Methode \texttt{draggable()} verschiebbar gemacht. Da sich diese graphischen Features noch in Entwicklung befinden, verweisen die Importe auf die neuesten Versionen von jQuery.

\subsection{script.aculo.us}
script.aculo.us ist ein Aufsatz für das Prototype-Framework und wurde von Thomas Fuchs entwickelt\cite{script}. Es wurde im Juni 2005 vorgestellt und ist unter der MIT-Lizenz erhältlich.

\subsubsection{Einbindung} Das script.aculo.us-Framework besteht aus sechs einzelnen Java\-Script-Dateien. Analog wie im Abschnitt "`Einbindung"' von \ref{import} müssen die Dateien über den \texttt{<script>}-Befehl importiert werden.

\subsubsection{Benutzung}
Ähnlich wie bei jQuery wird script.aculo.us über das \$-Zeichen angesprochen. Als Parameter wird das zu manipulierende Objekt übergeben. Über eine jeweilige script.aculo.us-Methode kann das Objekt manipuliert werden. Ein Beispiel für einen Einblendeffekt eines \texttt{<div>}-Objekts wird im folgenden Listing beschrieben:
\begin{lstlisting}[caption="", captionpos=b]
<script type="text/javascript" language="javascript">
  $('block').appear();
</script>
<body>
  <div id="block" style="width:80px;
      height:80px; background:#ffffff>
  </div>
  ...
</body>
\end{lstlisting}
Im Gegensatz zu jQuery besteht alternativ die Möglichkeit, das Verhalten direkt bei den Eventhandlern des \texttt{<div>}-Objekts anzugeben. Ein Beispiel hierfür:
\begin{lstlisting}[caption="", captionpos=b]
<div id="block" style="width:80px; height:80px;
    background:#ffffff onlick="$(this).appear()">
</div>
\end{lstlisting}
\subsubsection{Grafik und Interaktion}
script.aculo.us bietet keine Möglichkeit, eigene graphische Objekte zu erzeugen. Im Gegensatz zu jQuery gibt es allerdings eine Reihe von Möglichkeiten, verschiedene Objekte zu manipulieren. Ein unvollständiger Auszug aus der Liste der Möglichkeiten:
\begin{itemize}
\item draggable
\item droppable(),
\item appear()
\item fade()
\item grow()
\item shrink()
\item scale()
\item \dots
\end{itemize}
Es folgt ein Beispiel für die Erzeugung eines verschiebbaren Rechtecks:
\begin{lstlisting}[caption="", captionpos=b]
<script type="text/javascript">
  new Draggable('drag_demo_1');
</script>
<div id="block" style="width:160px; height:80px;
    background:#ffffff;">
</div>
\end{lstlisting}
Dieses Reckteck kann durch direkte Manipulation mit der Maus verschoben werden. Im Gegensatz zu jQuery kann ein in der Größe veränderbares Rechteck nicht erzeugt werden. Vielmehr lassen die Methoden \texttt{grow()}, \texttt{shrink()} und \texttt{scale()} nur Größenanderungen mit statischen Werten zu. Eine direkte Manipulation durch Interaktion mit der Maus ist damit nicht möglich.

\subsection{draw2d}
draw2d ist ein Aufsatz für das Mootools-Framework und wurde von Andreas Herz entwickelt\cite{draw}. Es wurde Ende 2007 vorgestellt und ist unter der LGPL-Lizenz erhältlich. Es wurde entwickelt, um eine graphische Zeichenkomponente für Workflows in einem Browser zu ermöglichen.

\subsubsection{Einbindung} Das draw2d-Framework besteht aus vier einzelnen Java\-Script-Dateien. Analog wie im Abschnitt "`Einbindung"' von \ref{import} müssen die Dateien über den \texttt{<script>}-Befehl importiert werden:
\begin{lstlisting}[caption="", captionpos=b]
<script src="wz_jsgraphics.js" type=text/javascript>
</script>
<script src="mootools.js" type=text/javascript>
</script>
<script src="moocanvas.js" type=text/javascript>
</script>
<script src="draw2d.js" type=text/javascript>
</script>
\end{lstlisting}

\subsubsection{Benutzung}
Um mit draw2d zeichnen zu können, muss zunächst ein Zeichenbereich definiert werden, in dem anschließend die graphischen Objekte gezeichnet werden. Das wird durch ein \texttt{<div>}-Objekt erreicht:
\begin{lstlisting}[caption="", captionpos=b]
<div id="canvas" style="width:1000px;height:750px"></div>
\end{lstlisting}
Die Benennung in "`canvas"' ist dabei willkürlich. Das eigentliche Objekt, in das später gezeichnet wird, ist das \texttt{workflow}-Objekt. Das muss mit dem Zeichenbereich assoziiert werden:
\begin{lstlisting}[caption="", captionpos=b]
<script>
   var workflow = new Workflow("canvas");
   ...
</script>
\end{lstlisting}
\subsubsection{Grafik und Interaktion}
Um ein einfaches, verschiebbares und in der Größe veränderbares Rechteck zu erzeugen, muss im Gegensatz zu den vorherigen Frameworks nicht auf ein \texttt{<div>}-Objekt zurückgegriffen werden. Vielmehr stellt draw2d dafür eigene Objekte zur Verfügung.
\begin{lstlisting}[caption="", captionpos=b]
<script>
  ...
  var rechteck = new Rectangle();
  rechteck.setDimension(160,80);
  workflow.addFigure(rechteck,250,300);
</script>
\end{lstlisting}
Mit der \texttt{addFigure}-Methode wird das erzeugte Rechteck dem Workflow hinzugefügt und kann so manipuliert werden.

\section{Prototyp: Draw2d und Serialisierung zu XML}
Im Rahmen des Seminars soll ein Prototyp entwickelt werden, mit dem man einen rudimentären Workflow-Graphen zeichnen kann. Der Workflow-Graph soll anschließend in ein XML-Format serialisiert werden. Der Prototyp wurde mit draw2d verwirklicht, da draw2d mehr Möglichkeiten zur graphischen Manipulation bietet als die anderen, in dieser Arbeit vorgestellten, Frameworks. Außerdem bietet draw2d Objekte und Methoden an, um einen vollständigen Graphen, bestehend aus Knoten und Kanten, zu modellieren. Draw2d bietet in seiner aktuellen stabilen Version 0.9.14 von sich aus keine Möglichkeit an, die gezeichneten Objekte in irgendein Datenformat zu serialisieren. Für zukünftige Versionen ist eine solche Möglichkeit angekündigt. Auf der Webseite von draw2d findet sich jedoch eine Demo, die einen rudimentären XML-Serialisierer zur Verfügung stellt. Auf Basis dieses Serialisierers wurde für den Prototypen eine Erweiterung enwickelt. Die Modellierung eines Workflows als Graph und die anschließende Serialisierung zu XML werden in den folgenden zwei Abschnitten näher erläutert.
\subsection{Die Klasse \texttt{FlowNode.js}}
Um mit Hilfe von draw2d in Ansätzen Workflows bzw. vereinfacht Graphen modellieren zu können, wurde ein neue draw2d-Klasse \texttt{FlowNode} erstellt, die Objekte vom Typen \texttt{Node} erstellt und zeichnet. \texttt{Node} respräsentiert einen Knoten. Der Einfachheit halber kann ein Knoten nur eine eingehende Kante und eine ausgehende Kante besitzen. Das wird durch sogenannte Input- bzw. Output-Ports verwirklicht. Code-Ausschnitt von \texttt{FlowNode.js}:
\begin{lstlisting}[caption="", captionpos=b]
/* Node wird erstellt */
var node = new Node();

/* Input-Port, eingehende Kante muendet hier */
var ip = new InputPort();
node.addPort(ip, node.width / 2, 0);

/* Output-Port, ausgehende Kante faengt hier an */
var op = new OutputPort();
node.addPort(op, node.width / 2, node.height);
\end{lstlisting}
\subsection{XML-Serialisierer}
Der draw2d-Workflow bietet über die Methode \texttt{getDocument()} Zugriff auf seine DOM-Struktur. Diese Struktur bietet weitere Methoden, um auf die einzelnen Zeichenobjekte des Workflows zuzugreifen. Die Methode \texttt{getFigures()} liefert beispielsweise eine ArrayList alle Zeichenobjekte eines Workflows zurück. Die Zeichenobjekte bieten wiederum Methoden an, um auf ihre Struktur zuzugreifen. Im Folgenden ein Ausschnitt des XML-Serialisiers (die Variable \texttt{xml} ist ein String, der zum Schluss das vollständige XML-Dokument repräsentiert):
\begin{lstlisting}[caption="", captionpos=b]
var xml = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n";
xml = xml + "<form>\n";

/* alle Zeichenobjekte in eine ArrayList holen */
var figures = document.getFigures();
for (var i = 0; i < figures.getSize(); i++) {
		
    /* Jedes Zeichenobjekt einzeln ansprechen */
    var figure = figures.get(i);
    xml = xml + "<" + figure.type + "\" id=\"" +
        figure.getId() + "\">\n";
        
    /* Falls ein Objekte Ports hat, werden diese in eine
     * ArrayList geholt
     * /
    if (figure.getPorts().getSize() > 0) {
        var ports = figure.getPorts();
        xml = xml + "<ports>\n"
        for (var j = 0; j < ports.getSize(); j++) {
            /* Auf Ports einzeln zugreifen */
            var port = ports.get(j);
            /* Connections = Kanten ermitteln */
            if (port.getConnections().getSize() > 0) {
                var connections = port.getConnections();
                for (var k = 0; k < connections.getSize(); k++) {
                    var connection = connections.get(k);
                    xml = xml + "<" + port.type + " targetId=\""
                        + connection.getTarget().getParent().getId()
                        + "\">\n";
                }
            }
        }
        xml = xml + "</ports>\n";
    }
       
    xml = xml + "</" + figure.type + ">\n";
}
xml = xml + "</form>\n";
\end{lstlisting}

\begin{thebibliography}{}
\bibitem{draw} Draw2D: http://draw2d.org, abgerufen am 5.1.2009.

\bibitem{ajax} Garrett, J.J. (2005): Ajax: A New Approach to Web Applications, http://adaptivepath.com/ideas/essays/archives/000385.php, abgerufen am 3.1.2009.

\bibitem{jquery} jQuery: Write less, do more, http://jquery.com/, abgerufen am 5.1.2009.

\bibitem{json} JSON: JavaScript Object Notation, http://json.org, abgerufen am 5.1.2009.

\bibitem{koch} Koch, S. (2006): JavaScript - Einführung, Programmierung und Referenz. Dpunkt Verlag, 4. Auflage.

\bibitem{script} script.aculo.us: web 2.0 javascript, http://script.aculo.us/, abgerufen am 5.1.2009.

\bibitem{ecma} Standard ECMA-262 (1999): ECMAScript Language Specification, http://www.ecma-international.org/publications/standards/Ecma-262.htm, abgerufen am 3.1.2009.

\bibitem{wenz} Wenz, C. (2006): JavaScript und Ajax. Galileo Press, 7. Auflage.
\end{thebibliography}

\end{document}